---
title: 多线程并发的三个概念
date: 2020-07-21 23:25:50
tags: Java基础
---

1. 缓存一致性问题

   初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。最终结果i的值是1，而不是2。

2. 并发编程三个概念

   * 原子性

     即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

     例如银行转账。

     ```java
     x = 10;     //语句1
     y = x;     //语句2
     x++;      //语句3
     x = x + 1;  //语句4
     ```

     除了x=10，其他都不是原子性的；

     y = x: 先读x的值，再把x的值赋给y

     x ++ :先读x的值，再x+1，再把x+1后的值赋给x

     x = x+1: 同上

     **只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。**

   * 可见性

     可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

     ```java
     //线程1执行的代码
     int i = 0;
     i = 10;
      
     //线程2执行的代码
     j = i;
     ```

     假若执行线程1的是CPU1，执行线程2的是CPU2。

     由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到**CPU1的高速缓存**中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却**没有立即写入到主存**当中。

     所以此时线程2执行，从主存中取出来i的值的时候，还是0

     线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

   * 有序性

     即程序执行的顺序按照**代码的先后顺序**执行。

     举个简单的例子，看下面这段代码：

     ```java
     int i = 0;
     boolean flag = false;
     i = 1;                //语句1  
     flag = true;          //语句2
     
     ```

     上面代码由于语句1和语句2没有互相依赖，对最终的程序结果并没有影响，所以JVM执行的时候有可能会发生指令重排序。（先执行语句2，再执行语句1）

     指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序**最终执行结果**和代码**顺序执行的结果**是一致的。

     但是需要保证程序最终结果会和代码顺序执行结果相同：

     保证程序最终结果会和代码顺序执行结果相同：

     ```java
     int a = 10;    //语句1
     int r = 2;    //语句2
     a = a + 3;    //语句3
     r = a*a;     //语句4
     ```

     语句3不会再语句4之前执行；

     原因在于：代码顺序，语句3在语句4之前，而且语句4需要用到语句3的结果（有依赖），所以就不会重排序。处理器会保证语句3会在语句4之前执行。

     But如果是多线程，就可能有问题：

     ```java
     //线程1:
     context = loadContext();   //语句1
     inited = true;             //语句2
      
     //线程2:
     while(!inited ){
       sleep()
     }
     doSomethingwithconfig(context);
     ```

     线程1的两个语句没有必然联系，所以可能重排序，假如先执行了语句2，那么线程2判断的时候就跳出了while循环，就会有问题。所以多线程的有序性会有问题！